{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Kyu2.Imperative where

import qualified Data.Map as M
import Control.Monad.State
import Control.Monad

newtype SomeMonad a = SomeMonad (State (Integer, M.Map Integer Integer) a) deriving (Applicative, Monad)
data SomeVariable = SomeVariable {getInt :: Integer} | Constance Integer

instance Functor SomeMonad where
  fmap f (SomeMonad st)= SomeMonad (fmap f st)

makeST = SomeMonad . state
evalST (SomeMonad m) = evalState m
execST (SomeMonad m) = execState m

def :: SomeMonad SomeVariable -> Integer
def m = getInt $ evalST m (0, M.empty) 
var :: Integer -> SomeMonad SomeVariable
var v = makeST (\(k, mp) -> (SomeVariable k, (k+1, M.insert k v mp)))
lit :: Integer -> SomeVariable
lit = Constance

while :: SomeVariable -> (Integer -> Bool) -> SomeMonad () -> SomeMonad ()
while sv f m = makeST (\(k, mp) -> if f $ mp M.! getInt sv 
                                      then ((), execST (while sv f m) (k, mp)) 
                                      else ((), (k, mp)))

(+=) :: SomeVariable -> SomeVariable -> SomeMonad ()
(SomeVariable k) += (Constance v) = makeST (\(k, mp) -> (k, M.insert ))

--
-- com = def $ do
--   a <- var 1
--   b <- var 2
--   return b

-- main = print com
